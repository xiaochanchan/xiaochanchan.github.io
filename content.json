{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"SSH","slug":"SSH","date":"2017-02-03T07:18:30.000Z","updated":"2018-12-02T14:13:41.366Z","comments":true,"path":"2017/02/03/SSH/","link":"","permalink":"http://yoursite.com/2017/02/03/SSH/","excerpt":"","text":"Hibernate1.Hibernate优点：1）对象/关系数据库映射(Basic O/R Mapping)它使用时只需要操纵对象，使开发更对象化，抛弃了数据库中心的思想，完全的面向对象思想。2）透明持久化(Persistent)带有持久化状态的、具有业务功能的单线程对象，此对象生存期很短。这些对象可能是普通的JavaBeans/POJO，这个对象没有实现第三方框架或者接口，唯一特殊的是他们正与（仅仅一个）Session相关联。一旦这个Session被关闭，这些对象就会脱离持久化状态，这样就可被应用程序的任何层自由使用。（例如，用作跟表示层打交道的数据传输对象。）3）事务Transaction (org.Hibernate.Transaction)应用程序用来指定原子操作单元范围的对象，它是单线程的，生命周期很短。它通过抽象将应用从底层具体的JDBC、JTA以及CORBA事务隔离开。某些情况下，一个Session之内可能包含多个Transaction对象。尽管是否使用该对象是可选的，但无论是使用底层的API还是使用Transaction对象，事务边界的开启与关闭是必不可少的。 （4）它没有侵入性，即所谓的轻量级框架。 （5）移植性会很好。 （6）缓存机制。提供一级缓存和二级缓存。 （7）简洁的HQL编程。2.Hibernate缺点：1）Hibernate在批量数据处理的时候是有弱势。 2）针对某一对象(单个对象)简单的查\\改\\删\\增，不是批量修改、删除，适合用Hibernate；而对于批量修改、删除，不适合用Hibernate，这也是OR框架的弱点;要使用数据库的特定优化机制的时候，不适合用Hibernate。Hibernate与Mybatis的区别相同点：1）Hibernate与MyBatis都是通过SessionFactoryBuider由XML配置文件生成SessionFactory，由SessionFactory 生成Session，由Session来开启执行事务和SQL语句。2）Hibernate和MyBatis都支持JDBC和事务处理。3）基于ORM思想解决了entity和数据库的映射问题不同点：1）sql方面：mybaits通过mapper.xml维护映射结果，程序员手动编写sql相比hibernate自动生成hql（hibernate sql）更加灵活，hibernate的hql数据库移植性更好，体现在强壮性。hibernate在级联删除的时候效率低；数据量大， 表多的时候，基于关系操作会变得复杂。 2）缓存方面：mybatis和hibernate都可以使用第三方缓存，而hibernate相比maybatis有更好的二级缓存机制。Hibernate环境搭建1、部署jar文件2、创建Hibernate配置文件hibernate.cfg.xml 3、创建持久化类和映射文件（映射文件名与持久类同名以“.hbm.xml”为后缀） 主键查询一条数据:1、session.get(Class clazz,Serializable id);2、session.load(Class clazz.Serializable id)开启事务:session.beginTransaction()新增:session.save(实体类对象)；修改:Dept dept=session.load(Class clazz.Serializable id)dept.setName(“张三”)；dept.setAge(18);删除:Dept dept=session.load(Class clazz.Serializable id) session.delete(dept);Hibernate中Java对象三种状态1瞬时状态（Transient）通过new创建对象后，对象并没有立即持久化 他并未与数据库发生任何关系，此时java对象的状态为瞬时状态，Session对与瞬时状态的对象一无所知，当对象不在被其他对象引用时他的数据也就丢失了，对象将按照垃圾回收机制处理2持久状态（Persistent）当对象与Session关联 被Session管理时 他就处于持久状态，处于持久状态的对象拥有数据标识（数据库中的主键值）那么对象是什么时候与session对象关联的呢有两种方式：第一种通过Session的查询接口或者是get（）方法或者是load方法（）从数据库中加载对象的时候，家在状态的对象，通过调用session的save方法或者saveOrUpdate方法时java对象也与session发生关联，对于处于持久状态的对象，session会跟踪和管理他们，如果对象的内部状态发生了任何变化，hibernate会选择合适的实际（如事务提交时）将变更固化到数据库中。3游离状态（Detached）处于持久化的对象 脱离与其关联的Session管理后对象就处于游离状态，处于游离状态的对象Hibernate无法感知到对象的任何操作Session提供了两个方法（Update（） merge（））将处于游离状态的对象与一个新的session发生关联，这是对象的状态就从游离转持久化。 脏检查（数据前后发生变化的对象）示例：Dept dept=session.load(Class clazz.Serializable id)dept.setName(“张三”)；dept.setAge(18);刷新缓存机制1、应用程序调用session的flush()方法时 2、应用程序调用Transaction的commit()方法时HQLQuery对象String hql=”from Dept”;Query query=session.createQuery(hql);参数绑定1、按参数位置绑定//参数为字符串调用 setString()方法……..，第一个参数代表位置，第二个代表hql中的值String hql=”from Dept where id=? and name=?”;Query query=session.createQuery(hql);query.setInt(0,12);query.setString(1,”张三”)；2、按参数名称绑定String hql=”from Dept where id=:id and name=:name”;Query query=session.createQuery(hql);query.setInt(“id”,12);query.setString(“name”,”张三”)；//query接口中定义不同类型的参数方法，同时还提供了setParameter()用来绑定任意类型Query分页查询setFirstResult(其实位置)setMaxResults(页数)实例：List list=session.createQuery(“from Emp”).setFirstResult((pageNo-1)*size) .setMaxResults(size);关联映射对象间的关联分为一对多，多对一和多对多等几种情况，关联是有方向的，可以是双向关联，也可以是单向的关联 hibernate通过配置的方式，将对象的关联关系映射到数据库上，方便完成多表的持久化操作连接查询现在假设有user和stundent两张表1.默认查询的情况:from User u where u.name like ‘%Java%’2.迫切左外连接from User u left join fetch u.student s where u.name like ‘%java%’3.左外连接from User u left join u.student s where u.name like ‘%java%’4.迫切内连接from User u inner join fetch u.student where u.name like ‘%java%’5.内连接from User u inner join u.student where u.name like ‘%java%’6.右外连接from User u right join u.student where u.name like ‘%java%’ 总结大概就这些吧!对于迫切连接的话,基本区别在于如果是用迫切连接的话当进行连接检索时student集合会立即被初始化,而后者采用的是映射文件配置的延迟检索策略,因此student集合不会被立即初始化聚合函数count() //统计条数sum() //和min() //最小值max() //最大值 avg() //平均值子查询关键字all 返回所有记录any 返回任意一条记录some “any”相同in “=any”相同 exists 至少返回一条语句注解Hibernate提供了注解功能，可以代替hbm.xml文件完成关系映射工作Hql持久化类常用注解 @Table可以省略，省略时表名必须与持久化名相同 @Column可以省略，省略时字段名必须与属性名相同","categories":[],"tags":[]},{"title":".NET","slug":"NET","date":"2017-01-15T03:28:30.000Z","updated":"2018-12-02T14:15:21.859Z","comments":true,"path":"2017/01/15/NET/","link":"","permalink":"http://yoursite.com/2017/01/15/NET/","excerpt":"","text":"第一章.NET框架的魅力1、完全支持面向对象编程2、.NET框架提高了软件的可复用性、扩展性、维护性和灵活性3、对Web应用的强大支持和Web服务的支持 4、实现SOA，支持云计算.NET框架的两个主要组件CLR（公共语言运行时）1、CTS(通用类型系统，全拼（“Common Type System”))2、CLS(公共语言规范，全拼（“Common Language Specification”))1、管理代码是CLR的基本功能2、能被其管理的代码叫托管代码，反之叫非托管代码3、C#和VB.NET都是CLR的托管代码4、CTS用与解决不同语言数据类型不同的问题FCL（框架类库）核心类库1、System:此命名空间包含所有其他命名空间2、System.Collections.Generic：支持泛型操作3、System.IO:支持对文件的复制，粘贴，删除，读取4、System.Net:支持对网络协议的编程5、System.Data:表示对ADO.NET结构类的访问6、System.Windows.Forms：用于开发Windows应用程序 7、System.Drawing：支持GDI+基本图形操作封装：1、一个不可分割的独立实体2、隐藏内部的细节 3、保留对外接口类和对象的关系：1、类是一个概念 2、对象是具体的实体第二章值类型和引用类型1、值类型（struct、float、bool、enum、int 、double……）值类型来自System.ValueType类库，值类型存储在栈中，值类型如要包括基本数据类型（如int、double、float）和枚举类型。不同的变量会存储在不同的内存中，并且存储空间存储的是该变量的值，赋值操作传递的是变量的值，改变一个变量的值不会影响另一个变量的值2、引用类型(delegate、class、interface、object、string.数组…..)string 是一个特殊的引用类型，传递参数不会保留值引用类型来自System.Object类库，在C#中主要包括（数组，类，接口）等对与引用类型，赋值是把原对象的引用传递给另一个引用，对于数组而言，当一个数组引用赋值个另一个数组引用后，这两个引用指向同一个数组，也就是指向同一块存储空间，改变其中一个数组的值另一个数组改变（指向同一个存储空间所以共用的是一个数组）数据类型分类 结构（值类型数据）结构的定义访问修饰符 struct 结构名{//结构体}结构的特点：1、结构中可以有字段，也可以有方法但必须有方法体2、定义时，结构中的字段不能被赋初值结构的使用:1、可以不用new,直接定义结构的对象，但不能调用属性2、声明结构的对象后，必须给结构的成员赋初值案例： 装箱和拆箱值类型和引用类型两者可以相互转换，将值类型转换为引用类型的过程称为装箱，反之为拆箱 值方式1、使用引用类型作为参数参数在方法中会被保留，结果会改变引用参数的值2、使用值类型作为参数参数在方法中不会被保留，结果不会改变值类型参数的值引用方式（加ref）1、使用引用类型作为参数参数在方法中的修改都会保留2、使用值类型通过作为参数 参数在方法中的修改都会保留第三章集合ArrayList命名空间（System.Collections）是一个可动态维护长度的集合，访问元素需要拆箱缺点：1、对象存储不易控制2、类型转换容易出错 对象初始化器 元素初始化器 案例： 输出集合中的元素: Hashtable命名空间（System.Collections）Key(键) Value（值）键和值一一对应不呢通过索引访问元素， 案例： 输出集合中的元素: 泛型和泛型集合泛型的重要性：1、实现代码重用，未来的主流技术2、性能高，无需进行类型转换避免繁琐的装箱拆箱3、提供了更好的类型安全性4、CLR支持泛型5、可以约束它所存储的对象的类型List命名空间（System.Collections.Generic）1、泛型集合最常见的用途是创建集合类2、泛型集合可以约束集合内的元素类型3、典型的泛型集合List、Dictionary&lt;K,V&gt;4、访问元素不需要拆箱案例： 输出集合中的元素: Dictionary案例： 输出集合中的元素: 泛型类： 绑定dgv 第四章构造函数特点：方法名与类名相同方法没有返回值主要完成对象的初始化工作1、构造函数是类中一种特殊得方法2、构造函数名必须与类名相同，没有返回值，完成对象初始化工作3、构造函数在(new)得时候被调用4、调用得参数要和参数一一对应 5、有参构造函数会覆盖无惨构造函数，默认为无惨构造函数方法的重载三个要素判断：方法名相同方法参数类型不同或者参数个数不同在同一个类中例如 Convert.WertLine();就是重载；1、如果两个重载的方法参数相同会报错2、方法的重载跟返回值无关,可以没有也可以不同3、方法的重载方法名必须相同4、构造函数的重载也叫方法的重载 5、方法的重载是指方法名相同，而参数类型和参数个数不同对象交互1、在面向对象的世界里，一切皆为对象。对象与对象相互独立，互不干涉2、在面向对象中，对象通过公开方法和属性完成与其他对象的交互，可以认为方法的参数及方法的返回值都是对象间相互传递的信息封装：隐藏现实细节，公开某种功能作为与外界通信的通道注意：1、每个对象都具有特定的功能，相对其他对象而言，它的功能就是为其他对象提供的服务2、没有给对象赋值，调用对象会报错 3、对象必须初始化，不然调用会报错第六章继承1、子类继承父类得方法：class 子类：父类{……..}2、子类继承父类，父类派生子类叫（子承父业）3、父类又叫基类，子类又叫派生类4、子类的权限不能比父类高5、base可以调用父类中的属性、方法和构造函数，而this表示自身6、protected只允许继承它的子类访问，但是可以通过构造函数访问 7、一个类如果使用 sealed修饰类，这个类是不能被继承的被称为（密封类）1、父类中有构造函数时，子类会默认调用父类的无参构造函数2、 如果父类在有参构造函数的情况下没有显示无参构造函数，子类构造函数必须指明调用父类哪个构造函数，默认为无参，无参被隐式会报错 3、C#中子类不能继承多个父类减少判断 1、父类中写一个虚方法使用关键字：virtual,子类中重写方法使用 override多态1、多态就是指多种形态，同一个类在不同场合下表现出不同的行为特征 2、方法重载也是实现多态性的一种方式，只不过重载的方法都在同一个类中，而用虚方法实现多态的方法分散在有继承关系的多个类中。第七章里氏替换原则1、在一个软件系统中，子类对象可以替换所有使用的父类对象，且程序行为没有发生变化，但父类对象不行替换子类对象2、可以把父类作为参数类型，把子类及子类对象作为参数传入is 和 asis可以用来判断类型是否兼容as用来转换类型，转不了不会报错而是返回一个空的对象has:包含，协同 如果p类里放入一个 A类，就是 p has A例：class p{ A a;}语法: if(item is SE){SE se=item as SE }抽象类1、有抽象方法的类必然是抽象方法，但抽象类中不一定都是抽象方法2、使用 abstract 修饰抽象类和抽象方法3、抽象类中不能有方法体，因为没有意义4、子类必须实现抽象父类的所有抽象方法（除非子类也具有抽象性）5、抽象类不能被实例化，因为抽象类是不够具体的6、抽象类不能密封或者是静态的7、快捷键调入父类的抽象方法：（1）Shift+Alt+F10+Enter（2）override+空格8、父类提供一些共性的行为，但是不去实现8、abstract可以和 类、方法、属性、索引器、事件一起使用，不能和构造函数，运算符、和字段一起使用抽象方法和虚方法： 面向对象三大特征：封装：隐藏内部实现，稳定外部接口继承：子类继承父类成员，实现代码复用 多态：不同子类对同一个消息做出不同反应第八章xml1、&lt;?xml version=”1.0” encoding=”uft-8”?&gt;//version：版本，encoding：编码2、XML称为可扩展标记性语言，主要用于描述数据3、XML节点区分大小写（前后对节点一一对应）成对出现，可自由扩展4、读取导入 using System.Xml;命名空间 案例：xml文件： 读取：方法1： 方法2： 当前节点名称：Name当前节点值：InnerText 当前节点的子节点：InnerXmlTreeView的使用1、TreeView用于显示具有层次结构的信息2、TreeView主要属性有Nodes和SelectedNode3、TreeNode表示TreeView的节点对象TreeView重要属性和事件 节点对象（TreeNode）的属性 在TreeView中添加根节点： 在TreeView中添加子节点： 删除TreeView中选中的节点： 清空 TreeView中选中的节点的子节点： 第九章如何读写文本文件步骤：创建一个文本流——创建相应的读写器（reader and writer）——执行读写操作——关闭读写器（reader and writer）——关闭文件流第一步：引入 System.IO命名空间第二步、使用文件（FileStream类）： FileMode枚举类型的成员 第三步、创建文件读写器： StreamReader读取器的主要方法：1、StreamReader.ReadLine();读取文件流中的一行数据，并返回字符串2、StreamReader.ReadToEnd();从当前位置读到末尾，返回字符串3、StreamReader.Close();用于关闭读取器 StreamWriter写入器的主要方法：1、StreamWriter.Write();用于写入流，这个流就是我们创建好的流2、StreamWriter.WriteLine();用于写入一行数据，写入某些数据后跟换行符3、StreamWriter.Close();用于关闭写入器案例： 打开文件路径：1、导入控件 openFileDialog2、添加一个按钮（选择路径）3、双击按钮 File文件操作（删除，移动，复制） 复制： 移动： 删除： 方法二：需要实例化的FileInfo类（不需要安全检查） 使用方法案例： Directory目录操作（删除，移动） 1、目录操作没有复制移动： 删除： 方法二：需要实例化的DirectoryInfo类（不需要安全检查效率会高一些） 使用方法案例： 静态类和非静态类 1、静态方法只能调用静态方法2、静态成员只能由类名调用3、使用static修饰的成员称为静态成员4、使用实例对象调用的成员称为实例成员 调用静态成员：类名.变量名=XX;//给变量赋值类名.方法名（）;//调用静态方法典型的静态类 Console.WriteLine()；//Console静态类的WriteLine()方法小型资源管理器第一步：添加一个SplitContainer控件将窗体分成左右两个框架第二步：添加一个TreeView和一个LIstView控件第三步：修改ListView属性：并添加四列 第四步：双击窗体 第五步：双击TreeView的AfterSelect事件（选中节点触发的事件） 完成！！","categories":[],"tags":[]},{"title":"SSM","slug":"mybatis","date":"2016-11-27T06:18:39.000Z","updated":"2018-12-02T14:17:29.174Z","comments":true,"path":"2016/11/27/mybatis/","link":"","permalink":"http://yoursite.com/2016/11/27/mybatis/","excerpt":"","text":"官方网站(Github)：http://mybatis.org(进不去)https://github.com/mybatis/mybatis-3/releasesMVC：（Model View Controller）模型－视图－控制器Model1：jsp+javabean的开发模式,用户请求交给jsp，然后jsp通过调用javabeans来进行数据库的访问和数据处理。Model2：是MVC的体现，javabeans是Module，而jsp仅仅充当View，Servlet是controller。jsp向servlet提交数据，servlet进行javabeans的实例化和调用，而javabeans进行数据库的访问读取。最后servlet将访问结果交给jsp呈现。ORM:（Object Relational Mapping）对象-关系-映射1、持久化是程序数据在瞬时状态和持久状态间转换的过程什么是JDBC？答：即Java数据库连接技术JDBC操作步骤答：1、加载驱动 2、连接数据库 3、执行SQL语句 4、处理结果 5、关闭连接框架技术优势：答：不用再考虑公共问题，框架已经写好，可以专心写业务逻辑，结构统一便于学习和维护主流框架介绍：1、Struts2（MVC设计模式web层框架）2、Hibernate（持久化框架Dao层框架）3、Spring（重点，结合框架）4、SpringMVC（高性能框架）5、MyBatis（半自动化ORM，Dao层，动态SQL,）6、shiro(安全框架)Mybatis框架的优缺点优点1、与JDBC相比，减少了50%以上的代码量2、最简单的持久化框架，小巧并简单易学3、SQL代码从程序代码中彻底分离，可重用4、提供XML标签，支持编写动态SQL5、提供映射标签，支持对象与数据可的ORM字段关系映射缺点1、SQL语句编写工作量大，对开发人员有一定要求 2、数据库一致性差Mybatis环境搭建：第一步：导入jar包到WEB-INF下的lib第二步：部署jar文件第三步：创建MyBatis核心配置文件（mybatis-config.xml）第四步：创建POJO（普通Java实体类（对象和数据库字段对应））第五步：编写SQL映射文件（XML文件） 第六步：创建测试类SqlSessionFactoryBuilder用过即丢SqlSessionFactory方法：openSession(boolean alim)true:关闭事务控制，false,表示开启事务最佳作用域范围：应用的全局作用域SqlSession 线程级SQL映射文件1、resultMap和resultType不能同时存在resultType：返回结果类型或对象resultMap：返回多个对象的集合2、当使用注解@Param()时不用写parameterType=“”标识传入的类型了3、SqlSessionFactory.openSession(boolean bol)true:表示关闭事务提交，false:表示开启事务提交4、增删改操作中没有 resultType或resultMap因为返回类型只有一种就是int resultMap 动态SQL1、where可以自动过滤 and||or2、chosses相当于java中的switch，通常于when和otherwise使用3、trimprefix:有返回值的情况下加上 前缀suffix:加上后缀prefixOverrides: 忽略首部的指定内容suffixOverrides:忽略尾部出现的指定内容4、foreach（通常用于in条件）item：集合中每一个元素别名index:迭代的位置open:语句开始指定用什么separator:每次迭代结束使用什么分割close:语句结束指定用什么collection:指定不同的值：List:list数组：array5、iftest属性判断条件成立进 Spring总结https://mp.weixin.qq.com/s/QswWwM1zhrtYaeqyji_bYQ1、轻量级框架，当前主流的框架2、“一站式”的企业应用框架3、IoC容器（控制反转）：把对象创建交给spring进行配置数据访问支持：1、简化JDBC/ORM框架 2、声明式事务DI依赖注入：向类里面的属性中设置值关系：依赖注入不能单独存在，需要在ioc基础上完成操作4、所谓面向切面编程，是一种通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态添加功能的技术5、工厂（Factory）：相当于代理类，工厂负责根据用户的描述信息生产符合规范的产品在工厂模式中6、控制反转（工厂模式）AOP（代理模式）Spring的优点：1）低侵入式设计2）独立于各种应用服务器3）依赖注入特性将组件关系透明化，降低了耦合度4) 面向切面编程特性允许将通用任务进行集中式处理5) 与第三方框架的良整合Spring体系结构 IOCioc底层实现的原理： Bean标签中常用属性（1）id属性：其名称，id属性值名称任意命名id属性值不能包含特殊符号，根据id值得到配置对象（2）class属性：创建对象所所在类的全路径（3）name属性：功能和id属性一样，但是可以包含特殊符号，起多个引用名称，（4）scope属性：默认值：singleton(单例模式)prototype(多例)属性注入三种方式：1、使用set方法注入2、使用有参构造注入3、使用接口注入 名称空间注入 Spring整合web项目原理1、加载核心配置文件（new ClassPsthXmlApplicationContext(“….xml”)）2、实现思想：把加载配置文件和创建对象的过程，在服务器启动时完成3、实现原理：1）ServletCOntext对象2）监听器3）具体使用—在服务器启动时候，为每个项目创建和一个ServletContext对象—在ServletContext对象创建时候，使用监听器可以具体到ServletContext对象在什么时候创建–使用监听器听到ServletContext对象创建时候–加载Spring配置文件，把配置文件配置对象创建–把创建出来的对象放到ServletContext域里面（setAttribute方法） 4–获取对象时候，到ServletContext域得到（getAttribute方法）AOP（Aspect Oriented Programming）目标：专注于业务逻辑原理：将复杂的需求分析出不同方面，将公共功能集中解决采用代理机制组装起来运行，在不改变原程序的基础上对代码进行强制处理，增加新的功能AOP相关术语1、增强/通知（Advice)前置增强（方法之前增强）\\后置增强\\环绕增强\\异常抛出\\最终增强2、切入点（Pointcut）在类中有很多方法可以被增强，实际被增强的方法就做切入点3、连接点（Joinpoint）类里面可以被增强的方法，这些方法就叫做连接点4、切面（Aspect）：把增强用到具体切入点上面的过程叫做切面5、目标对象（Target object）代理的目标对象（要增强的类）6、Aop代理（AOP proxy）一个类被AOP织入增强后，就产生一个结果代理类7、织入（Weaving） 把增强（advice）用到target(类）的过程叫做织入使用AOP步骤：1、在项目中添加Spring AOP的jar文件2、编写前置增强和后置增强实现日志功能3、编写Spring配置文件，对业务方法进行增强处理4、编写代码获取带有增强处理的业务对象； 环绕增强： Spring的bean管理（注解）创建对象四个注解(使用方式都相同，没有太大区别) 属性赋值注解1、Autowired //自动注入2、Resource(name=””) //name中写注解创建dao对象value值 一般使用文件和注解混合使用，创建对象用配置文件的方式，属性赋值用注解的方法AspectJ1、spectJ不是Spring的一部分，只是和Spring一起使用进行AOP的操作2、使用aspectj实现aop有两种方式1）基于aspectj的XML配置2）基于aspectj的注解方式 Spring和Mybatis整合开发步骤 Spring事务管理方式一编程式（不用）方式二声明式需要配置XML使用注解实现Spring为不同的持久化（dao）框架提供了不同PlatformTransactionManager接口实现 MVC：（Model View Controller）模型－视图－控制器Model1：jsp+javabean的开发模式,用户请求交给jsp，然后jsp通过调用javabeans来进行数据库的访问和数据处理。Model2：是MVC的体现，javabeans是Module，而jsp仅仅充当View，Servlet是controller。jsp向servlet提交数据，servlet进行javabeans的实例化和调用，而javabeans进行数据库的访问读取。最后servlet将访问结果交给jsp呈现。","categories":[],"tags":[]},{"title":"SQL Server","slug":"SqlServer","date":"2016-11-15T01:30:12.000Z","updated":"2018-12-01T03:21:36.073Z","comments":true,"path":"2016/11/15/SqlServer/","link":"","permalink":"http://yoursite.com/2016/11/15/SqlServer/","excerpt":"","text":"数据库基本概念：实体和记录实体：所有客观存在的，可以被描述的事物。记录 ：每一行对应一个实体，在数据库中，通常叫做一条记录数据冗余：数据重复的现象数据完整性：数据库中数据的准确性。 新建一个数据库：1.在ssms中的菜单栏中选择“文件”——“连接对象资源管理器”选项，弹出“连接服务器对话框”。2.在服务器名称 下拉列表框中选择连接过的服务器。也可以选择 浏览更多 选项来选择其他的服务器。3需要身份验证： Windows身份验证 SQL Server身份验证。 新建数据库登录名：1.在安全性节点下，点击登录名，在弹出的快捷菜单中选择 新建登录名 选项2.在新建登录对话框中数据登录名，密码，并指定其默认的数据库。3.有了登录名，还需要赋予该登录名操作权限，否则它将只能连接到服务器，而没有任何操作权限。 新建数据库用户：1.在指定数据库安全性节点下，右击用户，在弹出的快捷菜单中选择“新建用户”选项。2.在新建对话框中输入用户的名称，选择关联得到登录名，有了用户名和关联登录名之后 还需要赋予用户对该数据库的操作权限。 创建数据库:1.数据库文件：存放数据库数据和数据库对象文件2.事务日志文件：用来记录数据库的更新情况，在对数据库进行操作时，数据库中内容更改的操作信息都会记录在此文件中。3.文件组：主要用于分配磁盘并进行管理 分离和附加数据库：1.右击数据库，在弹出快捷菜单中选择 任务 分离选项。将打开数据库窗口，可以对数据库执行分离操作。单击确定按钮以后，分离的数据库将不再显示在数据库列表中，但是其物理文件依然保存在磁盘中，此时磁盘文件可以复制 粘贴的。2.把磁盘上的数据库文件复制到其他计算机后，通过附加 操作来恢复数据库。 备份和还原数据库:四种备份：完全备份，差异备份，事务日志备份，文件和文件组备份。 收缩数据库分为：自动和手动。 删除数据库： 数据库完整性：1.实体完整性约束：通过索引，唯一约束，主键约束或标识列属性，可以实现表的实体完整性。2.域完整性约束：通过限制数据类型，检查约束，输入格式，外检约束，默认值，非空约束来实现3引用完整性约束：再输入和删除数据行时，引用完整性约束来保持表之间已定义的关系。4.自定义完整性约束：用户自定义完整性用来定义特定的规则。 主键：用来唯一标识表中的每一行用于强制表的实体完整性.不允许有空值外检：用来强制引用完整性。一个表可以有多个外键 建立表间关系：1.在设计表的时候，在成绩中点击右键，在弹出快捷菜单选择关系选项弹出外键关系对话框。单击添加按钮可以添加新的关系。2单击表盒列的规范最右侧的小按钮，弹出要建立关系的逐渐表及主键列对话框3选择逐渐表为xx，主键列为xx，对应的外键表为xx，列为xx Sql简介：“结构化查询语句”，关系数据库的标准语言sql的运算符 ‘ + ‘ ‘ - ‘ ‘ * ‘ ‘ / ‘ ‘ % ‘赋值运算符 =比较运算符 = &gt; &lt; &lt;&gt; &gt;= &lt;= !=逻辑运算符 and or notuse –使用insert –插入into –到select –选择values –值default –默认from –哪里union –并集；结合delete –删除where –哪里update –更新；更改set –设置order by –排序asc –升序desc –降序percent –百分比T-SQL 里的两种注释1、单行注释： –2、多行注释： /**/ 增：单行增加方法1：写出列名,值与列名一一对应INSERT INTO 表名(列名，列名)values（值，值）方法2：不写列名,值与列中的列名一一对应INSERT INTO 表名values（值，值）方法3：遇到没有的信息可以使用default代替INSERT INTO 表名values（值，default）多行增加方法1（复制）：插入的新表必须存在，列也必须存在，新表和插入列数据类型要保持一致INSERT INTO 新表名（列，列，列）SELECT 插入表列，插入表列，插入表列FROM 插入表名方法2（复制）：新表可以没有，直接在INTO后面输入新表名SELECT 插入表列，插入表列，插入表列INTO 新表名FROM 插入表名方法3INSERT INTO 表名(列名，列名，列名)SELECT 值，值，值 UNIONSELECT 值，值，值 UNION SELECT 值，值，值 删：方法1：删除指定条件记录delete from 表名 //删除那个表里的东西where id=’1’ //这个表里哪个列方法2：删除含有外键表中对应值记录\\delete from 子表名where id=1godelete from 主表名where id=1 注意：删除主表的数据必须先删除子表中的数据，主表里有的数据，子表才能添加改：方法1：更新所有行UPDATE 表名SET 列名=’xx’ , 列名=’xx’, 列名=’xx’ 方法2:更改指定行UPDATE 表名SET 列名=’xx’ , 列名=’xx’, 列名=’xx’WHERE id=1 方法3:多条件更改指定行UPDATE 表名SET 列名=’xx’ , 列名=’xx’, 列名=’xx’ WHERE id=1 and name=’小朱’ 查：方法1：查询所有数据行SELECT * FROM 表名 方法2：查询部分行或列示例1SELECT 列名，列名FROM 表名where 性别=’男’ //条件等于男示例2SELECT 列名，列名FROM 表名where 性别&lt;&gt;’女’ //条件不等于女 方法3：方式1. 列名 AS 别名SELECT name AS 姓名，score AS 成绩FROM 表名where 性别&lt;&gt;’女’方式2. 别名=列名SELECT 姓名=name，成绩=scoreFROM 表名where 性别&lt;&gt;’女’方式3. 列名 别名SELECT 姓名 name，成绩 scoreFROM 表名where 性别&lt;&gt;’女’ 方法4：合并列表查看SELECT name+sex AS 姓名性别FROM 表名字符串列名+字符串列名整数类型+整数类型 方法5：查询空值 列名后加 IS NOT NULLSELECT * //显示查询的所有列FROM 表名WHERE semail IS NOT NULL 方法6：使用AS 可以加常量值SELECT 姓名=StudentName,地址=Address,’北京故宫’AS’学校名称’FROM dbo.Student 限制条件查询的两种方式1，按照固定数目查询SELECT TOP 3 //查询表的前三行， 代表所有行FROM 表名2，按照百分比查询SELECT TOP 50 PERCENT * //percent –百分比FROM 表名 使用ORDER BY 进行排序：查看排序:升序ORDER BY 列名 ASC查看排序:降序ORDER BY 列名 DESC 数据查询语句：1、查询将逐行筛选表中的数据，按条件从新组合成“记录集”2、使用IS NULL判断一行中的某列是否为NULL3、使用 ORDER BY进行排序，可以按多列排序4、在查询中，可以使用常量、表达式、运算符 5、在查询中使用函数可以完成更复杂的查询注意事项1：每次插入一行数据，不能插入半行或者几列数据插入的数据是否有效是按照整行的完整性的要求来检验的注意事项2：每个数据值的数据类型，精度和小数位数必须与相应的列的数据类型相同注意事项3：不能为标识列指定值注意事项4：如果在设计表的时候就指定了某列不允许为空，则必须插入数据注意事项5：插入的数据项，要求符合检查约束的要求注意事项6：具有缺省值的列（）可以使用default关键字来代替插入的数值注意事项7：所有代码必须在英文格式下完成注意事项8：数据类型非值类型必须使用 ‘ ‘ 引起 导出数据1.右击数据库，在弹出的快捷菜单中选择 任务，导出数据 选项2.选择要从何处取得数据 这时候可以选择SQL Server自身3.确定将数据导出到什么位置，这时候可以在上方的目标下拉列表框中选择 平面文件 选项 然后在 文件名 文本框中输入文件的名称或单击 浏览按钮选择文件名，并确定文件相关的选项，4.复制一个过多个表或视图的数据，单击下一步按钮5.选择表名并设置文本文件的格式。6 确定是否立即运行 单击系一部按钮一直到完成转换 导入数据1.首先准备数据2.有机数据库，在弹出的快捷菜单中悬着 任务-导出数据 xuanxiang3悬着要从何处取得数据呕4.悬着将数据源复制到目标源5确定后，单击下一步按钮，一直到完成转换。 第9章字符串函数 字符串函数1、获取指定字符串的索引号位置SELECT CHARINDEX(‘SERVER’,’sql server’,3)2、获取字符串的长度SELECT LEN(‘我们是SQLserver’) AS 长度3、转换大写字母的函数SELECT UPPER(‘SQL server函数’)4、转换小写字母函数SELECT LOWER(‘SQL SEver’)5、去掉左边空格SELECT LTRIM(‘ 你好 ‘)SELECT LEN(LTRIM(‘ 你好 ‘))6、去掉右边空格SELECT RTRIM(‘ 你好 ‘)SELECT LEN(RTRIM(‘ 你好 ‘))SELECT LEN(‘管理员 ‘+’注册’)SELECT LEN(RTRIM(‘管理员 ‘)+’注册’)注意: SQL sever 中不能去掉中间空格和同时去掉左右空格7、获取指定数目的字符串SELECT LEFT(‘史蒂夫顶顶顶’,4)从左边获取SELECT RIGHT(‘史蒂夫顶顶顶’,4)从右边获取8、替换子串的函数SELECT REPLACE(‘莫乐可切.可可’,’可可’,’宝宝’)9、替换并插入函数SELECT STUFF(‘12345678’,3,2,’ABCDEFG’)–数字代表从第三个子串截取两个数替换后面的字符 日期函数 日期函数 1查询当前的系统时间SELECT GETDATE() AS 系统时间2日期添加查询7天后的日期是几号SELECT DATEADD(day,7,GETDATE()) AS ‘7天后的日期’SELECT DATEADD(mm,7,GETDATE()) AS ‘7月后的日期’SELECT DATEADD(yy,7,GETDATE()) AS ‘7年后的日期’ 3日期减法（后面减去前面的日期）SELECT DATEDIFF(day,’2018-1-26’,’2018-2-26’) AS 相差多少天4指定显示日期中的某个部分SELECT DATENAME(dw,GETDATE()) AS 星期SELECT DATENAME(dd,GETDATE()) AS 日期SELECT DATENAME(mm,GETDATE()) AS 月份5日期中的整数部分LECT DATEPART(DW,GETDATE()) AS 日期SELECT DATEPART(dd,GETDATE()) AS 月份SELECT DATEPART(yy,GETDATE()) AS 年份SELECT DATEPART(ss,GETDATE()) AS 秒数 数学函数 数学函数：1随机数函数 0~1小数SELECT RAND() AS 随机数随机数函数 3~6之间的数SELECT RAND()(6-3+1)+3 AS ‘3-6随机小数’SELECT FLOOR(RAND()(6-3+1)+3) AS ‘3-6随机小数’2向上取值整数SELECT CEILING(‘45.34’) AS 比它大的最小整数3向下取值整数SELECT FLOOR(‘45.32’) AS 比它小的最大整数4幂值（5的3次方的值叫做 幂值 5称为底 3称为指数）SELECT POWER(5,3) AS l 5的3次幂5四舍五入SELECT ROUND(45.45536,2) AS 四舍五入精确精度 系统函数 聚合函数：sum()函数 –求和AVG()函数 –求平均值MAX()函数 –求最大值MIN()函数 –求最小值COUNT()函数 –统计行数 sum求和SELECT SUM(score)FROM dbo.成绩表 avg求平均分SELECT AVG(score)FROM dbo.成绩表 MAX最大值 MIN最小值SELECT AVG(score) AS 平均分,MAX(score) AS 最大值,MIN(score) AS 最小值FROM dbo.成绩表where score&gt;=60 COUNT 统计函数 输出查询列的行数SELECT COUNT(score) AS ‘大于80分的人数’FROM dbo.成绩表where score&gt;80 分组查询：–案例1：统计每学期的人数–按照年级分组SELECT 班级,COUNT(*) as 人数FROM dbo.学生信息GROUP BY 班级–注意：select后面查询的信息有聚合函数，那么，列名要么在聚合函数中出现，要么就使用分组进行查询 –案例2：查询每门课程的平均分SELECT AVG(分数) as 平均分, 学科from dbo.分数表GROUP BY 学科 –案例3：查询每门课程的平均分，并且按照分数由低到高排序SELECT AVG(分数) AS 平均分,学科from dbo.分数表GROUP BY 学科ORDER BY AVG(分数)–说明：order by 排序 可以对聚合函数排序或者列名排序默认都是asc –案例4：如何获取总人数超过2人的班级？SELECT COUNT() AS 人数, 班级from dbo.学生信息Group by 班级Having COUNT() &gt;2–说明：where 列名条件 Having 聚合函数条件，Having一般和GROUP BY 联用，放在GROUP BY 后面 –案例5：统计平均分大于60 分的课程的平均分SELECT 学科,AVG(分数)FROM dbo.分数表 –从哪里开始查找–WHERE 学科=1 –列名条件 模糊查询，关系表达式查询GROUP BY 学科 –分组筛选Having AVG(分数)&gt;50 –分组后的聚合函数筛选分析下面T-SQL: 分析：分类部门，显示工资超过2000的人数，并且部门人数要超过1人，不然不显示分组查询是根据表中不同的组分类查询输出的Having子句能够在分组的基础上，再次进行筛选GROUP BY是分组，ORDER BY是排序 先分组在排序在一个SQL语句中 group by, where having 使用次序： WHERE 子句从数据库中去掉不符合其搜索条件的数据；GROUP BY 子句搜索数据库行到各个组中，统计函数为各个组计算统计值；HAVING 子句去掉不符合其搜索条件的各组数据行 多表连接查询 内连接语句： 内连接查询：内连接查询是最典型。最常用的连接查询，它根据表中共同的列来进行匹配，特别是两个表存在主外键关系时通常会使用内连接查询外连接查询：外连接查询时至少返回一个表中的所有记录，根据匹配条件有选择性的返回另一张表的记录。外连接可以时左外连接或右外连接 INNER JOIN 用来连接两个表INNER 可以省略ON 用来设置条件 内连接查询通常不仅仅连接两个表，有时连接三个或更多示例：select s. sname as 学生姓名，cs.courename as 课程名称，c.score as 成绩from students as sinner join score as c on(s.scoder=c.studentid)inner join course as cs on(cs.courseid=c.courseid)案例1：使用内联接完成 查询学员姓名，科目号和分数内连接写法：SELECT 学生信息.studentNO,学生信息.姓名,分数表.学科,分数表.分数FROM 学生信息,分数表WHERE 分数表.学号=学生信息.studentNO内连接写法（简便写法）：SELECT S.studentNO,S.姓名,R.学科,R.分数FROM 学生信息 AS S,分数表 AS RWHERE R.学号=S.studentNO三个语法的显示结果相同： 语法格式:SELECT 表2.列名1,表2.列名2,表1.列名1,表1.列名2FROM 表1 as 别名 ，表2 as 别名WHERE 表1.主键列=表2.外键列 内连接写法2（使用 inner join）SELECT S.studentNO,S.姓名,R.学科,R.分数FROM 学生信息 AS Sinner join 分数表 AS Ron R.学号=S.studentNO语法格式：SELECT 表2.列名1,表2.列名2,表1.列名1,表1.列名2FROM 表1 as 别名 inner join 表2 as 别名on 表1.主键列=表2.外键列左外连接：原则：左边的表为主表，主表的信息全部显示，匹配的正常显示，不匹配的NULL值补位显示查询所有学生的考试成绩和姓名，科目名左外连接写法：SELECT 姓名,学科,分数FROM 学生信息left outer join 分数表on 学生信息.studentNO=分数表.学号显示结果： 左外连接写法2（左边从表，右边主表）：SELECT 姓名,学科,分数FROM 分数表left outer join 学生信息on 学生信息.studentNO=分数表.学号显示结果： 语法格式：SELECTFROM 主表LEFT OUTER JOIN 从表on 主表.通用列=从表.通用列 分组查询+连接查询1、分组查询是针对表中不同的组分类统计和输出的2、Having子句能够在分组的基础上，再次进行筛选 QQ项目 1–查询qq号为88662753的用户的所有好友select r.RelationQQID,NickName,Agefrom dbo.BaseInfo as binner join dbo.Relation as ron r.QQID=88662753 and r.RelationStatus=0 and r.RelationQQID=b.QQID 2–查询qq号为54789625的好友中每个省份的总人数 人数从大到小排序select b.Province, count() as 人数from dbo.BaseInfo as binner join dbo.Relation as ron r.QQID=54789625 and r.RelationStatus=0 and r.RelationQQID=b.QQIDgroup by b.Provinceorder by count() desc 3–查询qq号为54789625的好友中等级为10级以上的好友—方法1select r.RelationQQID as 好友qq,b.NickName,b.Age,u.Levelfrom dbo.Relation as r join dbo.BaseInfo as bon r.QQID=54789625 and r.RelationStatus=0 and r.RelationQQID=b.QQIDjoin dbo.QQUser as uon u.Level&gt;10 and u.QQID=r.RelationQQID–方法2select r.RelationQQID as 好友qq,q.Levelfrom dbo.QQUser as qinner join dbo.Relation as ron r.QQID=54789625 and r.RelationStatus=0 and r.RelationQQID=q.QQID and q.level&gt;10 4–查询被当作黑名单人物次数排名前20的用户select top 20 RelationQQID as qq号,COUNT() as 人数,NickNamefrom dbo.Relation as rinner join dbo.BaseInfo as bon r.RelationQQID=b.QQID and RelationStatus=1group by RelationQQID,NickNameorder by COUNT() desc select top 20 r.RelationQQID as qq号,COUNT() as 人数from dbo.Relation as rinner join dbo.BaseInfo as bon r.QQID=b.QQID and r.RelationStatus=1group by r.RelationQQIDorder by COUNT() desc 5–查询当前用户在线信息select *from dbo.QQUserwhere OnLine=0 6–查询qq号码为54789625的好友中隐身的用户信息select r.RelationQQID,b.NickName,b.Sex,b.Provincefrom dbo.QQUser as qinner join dbo.Relation as ron r.QQID=54789625 and r.RelationStatus=0 and q.OnLine=2 and r.RelationQQID=q.QQIDinner join dbo.BaseInfo as bon b.QQID=r.RelationQQID 6–查询好友超过20的信息–方法1select r.QQID,COUNT() as 好友数量,b.NickName,b.Sex,b.Age,b.Provincefrom dbo.Relation as rinner join dbo.BaseInfo as bon r.RelationStatus=0 and r.QQID=b.QQIDgroup by r.QQID,b.NickName,b.Sex,b.Age,b.Provincehaving COUNT()&gt;=20–方法2select b.NickName, COUNT() as 人数from dbo.BaseInfo as binner join dbo.Relation as ron b.QQID=r.QQID and RelationStatus=0group by b.NickNamehaving COUNT()&gt;=20 7–查询北京市 年龄在18~45岁在线用户的信息，select b.QQID,NickName,Sex,Age,Province,Cityfrom dbo.BaseInfo as binner join dbo.QQUser as uon City=’北京’ and Age&gt;=18 and Age&lt;=45 and u.OnLine=0 and u.QQID=b.QQID 8–查询昵称为‘小笨猪’的用户信息select NickName,Age,Sex,Province,QQID,Phonefrom dbo.BaseInfowhere NickName=’小笨猪’ 9–查询qq号码为 54789625的用户的好友中每个省份的总数，并且按照总人数由大到小排列select Province,count()from dbo.BaseInfo as binner join dbo.Relation as ron b.QQID=r.RelationQQID and RelationStatus=0 and r.QQID=54789625group by Provinceorder by count() desc 10–查询至少300天未登录qq的用户的qq号码和最后登录时间，等级，昵称，年龄，并按照时间降序排列select b.QQID,lastLogTime,Level,NickName,Age,DATEDIFF(day,lastLogTime,’2013-6-30’) as 多少天没有登录from dbo.BaseInfo as binner join dbo.QQUser as uon u.QQID=b.QQID and DATEDIFF(day,lastLogTime,’2013-6-30’) &gt;300order by DATEDIFF(day,lastLogTime,’2013-6-30’) 今天我隐身登录，假设我的qq号码为8855678update dbo.QQUserset OnLine=2,lastLogTime=GETDATE()where QQID=8855678修改我的昵称为“被淹死的鱼”地址为“解放中路6号院106室”update dbo.BaseInfoset NickName=’被淹死的鱼’,Address=’解放中路6号院106室’where QQID=8855678将我的好友“248624066”拖进黑名单update dbo.Relationset RelationStatus=1where QQID=8855678 and RelationQQID=248624066为了提高qq用户聊天的积极性，把等级小于六级的用户等级提示一级update dbo.QQUserset Level=Level+1where Level20select * from dbo.Relation where QQID=54789625把qq号码为286314的用户的好友“嘟嘟鱼”拖进黑名单update dbo.Relationset RelationStatus=1inner join dbo.QQUserwhere QQID=286314,把qq号码为54789625的用户黑名单中的用户删除deletefrom dbo.Relationwhere QQID=54789625 and RelationStatus=1qq号码为622013019用户多次在qq中发布违法信息，在关系表删除用户622013019的信息，在基本信息表中删除该用户，还有用户表deletefrom dbo.Relationwhere QQID=622013019deletefrom dbo.QQUserwhere QQID=622013019deletefrom dbo.BaseInfowhere QQID=622013019 ADO.NETADO.NET的主要组件： ADO.NET结构图： .NET数据提供程序：SQL Server ：使用 System.Data.SqlClient命名空间ADO.NET数据提供程序的四个核心对象：1 connection对象：负责连接数据库2 command对象：负责对数据库执行命令3 datareader对象：负责从数据源读取数据4 dataSAdapter对象：负责数据集和数据库的连接Connection对象的作用：建立应用成语与数据库之间的连接，相当于在两者之间建立一座桥梁Command对象的作用：执行命令从数据库中返回结果，相当于桥梁上的运输工具 不同的数据库连接相应的连接类： 连接数据库步骤： 示例分析代码： 使用Command步骤：1、创建数据库连接2、定义SQL语句3、创建Command对象4、打开连接对象5、执行命令6、关闭连接 Command对象主要方法：ExecuteNonQuery() 执行增、删、改(不执行查询)ExecuteReader() 执行读取数据ExecuteScalar()返回单个值，执行带count(*)的SQL语句如何处理异常：try 尝试catch 抓捕；捕获 String 和StringBuilderString类具有很多字符串处理方法，但在替换、添加、删除字符串时，StringBuilder类对象的执行速度要快很多，语法：//声明一个空的StringBuilder对象StringBuilder 对象名称=new Stringbuilder();//声明并赋值StringBuilder 对象名称=new Stringbuilder(”字符串初始值“)；StringBuilder对象常用的属性和方法：","categories":[],"tags":[]},{"title":"Mysql","slug":"mysql","date":"2016-07-26T10:12:36.000Z","updated":"2018-12-01T03:14:58.475Z","comments":true,"path":"2016/07/26/mysql/","link":"","permalink":"http://yoursite.com/2016/07/26/mysql/","excerpt":"","text":"数据库设计1、E-R图数据库设计的图形化表达方式，也称为实体-关系图2、矩形-实体集 椭圆-属性 菱形-联系集2、java通过JDBC连接MySQL数据库3、实体-关系模型包含（实体、属性、联系）4、关系模式即用二维表的形式表示实体和实体间联系的数据模型5、映射基数：一对一，一对多，多对一，多对多绘制数据库模型图的步骤1、新建数据库模型图2、添加实体3、添加数据列及相应的属性4、添加实体之间的映射关系数据模型的三要素:数据结构、数据操作、数据约束软件项目开发步骤：1、需求分析（收集信息，标识实体，标识每个实体的属性，2、概要设计（绘制E-R图，将E-R转换为数据库模型图）3、详细设计（将E-R图转换为多张表）4、代码编写5、测试6、安装部署三大范式第一范式：的目的是确保每列的原子性（不出现合并的属性）如果每列都是不可再分的最小数据单元，也称为最小的原子单元第二范式：要求每个表只描述一件事情（不出现表合并的现象）第三范式：如果一个关系满足第二范式，并且除了主键以外的其他列都不传递依赖于主键列，则满足第三范式 初始MySQLMySQL的优势：运行速度快，使用成本低，可移植性强，用户广泛两个版本：1、社区版（免费，开源）2、企业版（收费，不能自由下载，安全性高）MySQL运行机制 MySQL下载安装：看云课堂第三套第二章第二个视频MySQL安装目录：bin:可执行文件include：头文件lib：库文件share：字符集语言信息my.ini：配置文件使用命令：使用dos命令启动服务：打开服务：net start mysql57关闭服务：net stop mysql57使用dos命令登录数据库mysql -h 服务器主机地址 -u 用户名 -p 密码 1、创建数据库CREATE DATABASE 数据库名；判断是否有该数据库create database if exists 数据库名； Suery OK：SQL语句执行成功1 row affected:操作影响的行数0.00sec操作执行时间2、查看数据库列表SHOW DATABASES; 3、选择数据库USE 数据库名；有的话：changed没有：Unknown database 3、删除数据库DROP DATABASE 数据库名； 4、显示数据库表结构describe 数据库名SQL语言包括以下四部分： MySQL数据类型：数值类型 字符串类型 日期类型 创建表的语法： 字段的约束： 主键：primary key;删除表：drop table 表名；显示所有表：show tables；显示数据表结构：describe 表名；更新列的类型modify查看表中的所有列及类型：desc 表名；无符号数(正数)：unsigned限制位数：zerofill修改编码：SET NAMES 编码格式;查看字符集的设置：mysql&gt;show variables like ‘%char%’默认操作的内部操作字符集：character set serverBETWEEN 取值1 AND 取值2(包含1和2) 存储引擎的类型：MyISAM与InnoDB类型的区别： MyISAM类型表文件.frm:表结构定义文件 .MYD：数据文件.MYI:索引文件InnoDB类型表文件(默认) .frm:表结构定义文件 ibdata1文件字符集：character_set_server：内部操作character_set_client：客户端来源character_set_connection:连接层character_set_results:查询结果character_set_database:当前数据库默认character_set_system:系统元数据 高级查询（一） 修改表名： 添加新的字段： 修改字段： 修改字段长度命令alter table 表名 modify column 列名 类型(要修改的长度);删除字段： 修改添加主键 修改添加外键： 插入单条数据记录： 插入多条数据记录： 案例： 复制一张表（同时新建）： 复制一张表（已有的表）： 更新数据记录： 删除数据记录： 删除数据记录（不能加条件）： Select查询全部列select from student;代替列名显示select name as ‘姓名’ from student;select name ‘姓名’ from student;多条件查询(and：并且 or:或者)select from studnet where sex=’男’;模糊查询%：任意字符, _:一个字符, [a^z]区间一个字符select from student where name like ‘张%’；order by 排序：查看排序:升序ORDER BY 列名 ASC (默认)查看排序:降序ORDER BY 列名 DESCgroup by 分组：select count() from student group by sex;select count() from student;select count() from student; slecet count(1),subjcetno from resultgroup by subjectnohaving count(1)&gt;2;LIMIT子句LIMIT 4; 取前四行LIMIT 4，5 ; 省略前四行，取五行； 聚合函数 字符串函数 日期函数 数学函数 SQL server连接查询:连接查询：将多张表放一起动态查询内连接：查询多张表共有数据，不分主次；外连接：表分主次左外连接：先写的为主，后写的为次 右外连接：先写的为次，后写的为主可以通过两种方式关联多表查询1、表连接都可以用子查询替换，但有的子查询不能用表连接来替换2、子查询比较灵活，方便，形式多样表连接—-合并多个数据表中的字段子查询—-将一个查询嵌套在另一个查询中子查询适用于一个表的查询 表连接更适合查看多表的数据子查询查询年龄比李斯文小的学生信息select from student where borndate&gt;(select borndate from student where studentName=’李斯文’);查询和李斯文性别相同的学生信息select from student where sex=(select sex from student where studentName=’李斯文’);IN子查询成绩大于60的学生信息 select * from student where studentno in(select studentno from result where studentresult&gt;’60’);查询Logic java 课程考试成绩等于60分的学生； select * from student where studentno in(select studentno from result where studentresult=60 and subjectno=(select subjectno from subject where subjectname=’Logic Java’) );查询参加最近一次Logic Java考试成绩的学生的最高分和最低分select max(studentResult) ,min(studentResult) from result where examDate=(select max(examdate) from result where subjectno(select subjectno from subject where subjectname=’Logic Java’)) and subjectNo=(select subjectno from subject where subjectname=’Logic Java’ );查询参加最近一次参加Logic Java考试的学生信息；select * from student where studentNo in(select studentNo from result where examDate=(select max(examdate) from result where subjectno=(select subjectno from subject where subjectname=’Logic Java’)) and subjectno=(select subjectno from subject where subjectname=’Logic Java’) );查询S1所有的课程的课程名称；select subjectName from subject where gradeID =(select gradeID from grade where gradeName=’S1’ );查询没有参加“HTML”最近一次考试的学生名单；select * from student where studentNo not in(select studentNo from result where examDate=(select max(examdate) from result where subjectno=(select subjectno from subject where subjectname=’HTML’))and subjectno=(select subjectno from subject where subjectname=’HTML’)) and gradeid=(select gradeid from subject where subjectName=’HTML’);比较运算符后面的子查询自能返回单个数值 IN子查询可跟随返回多条记录的子查询高级查询（二）EXISTS子查询的语法select * from 表名 where exists(子查询);子查询有返回结果：exists子查询为true 子查询无返回结果：exists子查询为false,外层查询不执行显示Logic Java最近一次考试前5名的学生信息select studentNo,studentResult from result where exists(select studentNo,studentResult from result here subjectNo=(select subjectNo from subject where subjectName=’Logic Java’)and examDate=(select max(examdate) from result where subjectno=(select subjectno from subject where subjectname=’Logic Java’))and studentResult&gt;80)and subjectNo=(select subjectno from subject where subjectname=’Logic Java’)and examDate=(select max(examdate) from result where subjectno=(select subjectno from subject where subjectname=’Logic Java’))order by studentResult desc limit 5;显示Logic Java最近一次考试全部未通过60分的学生成绩加5select studentNo,studentResult+5 from result where not exists(select studentNo,studentResult from result where subjectNo=(select subjectNo from subject where subjectName=’Logic Java’)and examDate=(select max(examdate) from result where subjectno=(select subjectno from subject where subjectname=’Logic Java’))and studentresult&gt;=60)and subjectNo=(select subjectno from subject where subjectname=’Logic Java’)and examDate=(select max(examdate) from result where subjectno=(select subjectno from subject where subjectname=’Logic Java’) );如果有S2的学生，查询S2的学生的考试信息select from result where exists(select from student where gradeid=(select gradeid from grade where gradename=’S2’))and subjectNo in(select subjectno from subject where gradeid=(select gradeid from grade where gradename=’S2’) ); 显示6~10的房屋信息select from hos_houselimit 5,5;查询张三发布的所有房屋信息select from hos_house where uid=( select uid from sys_user where uName=’张三’ );事务，视图，索引事务事务是作为单个逻辑工作单元执行的一系列操作事务是一个不可分割的工作逻辑单元多个操作作为一个整体向系统提交，要么都执行，要么都不执行事务具备四个属性，1、原子性（事务是一个完整的操作，要么都执行，要么都不执行）2、一致性（数据必须一致）3、隔离性（并发事务之间彼此隔离，独立，他不应以任何方式依赖于或影响其他事务）隔离级别：READ COMMITTED4、持久性（事务完成后，它对数据库的修改被永久保持）开始事务：BEGIN; 或 START TRANSACTION;提交事务：COMMIT撤销事务：ROLLBACKSET autocommit=0|1;0 表示取消自动提交需要手动在每行后加commit才能生效;1 表示恢复自动提交功能尽量不适用事务查询数据视图视图是一张虚拟表视图上不可以创建索引表示一张表的部分数据或多张表的综合数据其结构和数据是建立在对表的查询基础上视图中不存放数据数据存放在视图所引用的原始表中一个原始表，根据不同用户的不同需求，可以创建不同的视图视图的用途筛选表中的行防止未经许可的用户访问敏感数据降低操作数据库的复杂程度 将多个物理数据库抽象为一个逻辑数据库创建视图 删除视图 查看视图 查看所有视图USE information_schema; Select * from views;创建索引 查看索引 查看全部索引 创建唯一索引：create unique index 索引两大类：聚集索引：有序非聚集索引：无序备份语法：mysqldump -u root -p myschool student&gt;e:aa.sql恢复语法： mysqldump -u root -p 新数据库 student&gt;文件地址创建权限语法：一 ， 创建没有权限的用户创建普通用户CREATE user user@host [identified password]案例：create user a@localhost identified by ‘1234’;创建普通用户， 无密码CREATE user user@host案例：create user b@localhost创建普通用户，密码1234，允许远程访问CREATE user user [identified password]案例：create user c identified by ‘1234’;二，创建有权限的用户,或者给没有权限的用户赋予权限给用户a，查询student表的权限grant select on myschool.student to a@localhost;给用户a，增删改student表的权限grant select,delete,update,insert on myschool.student to a@localhost;给用户a,student表的全部权限grant all on myschool.student to a@localhost;给用户a,myschool数据库的全部权限grant all on myschool. to a@localhost;给用户a所有数据库的全部权限grant all on . to a@localhost;三，查看用户权限查看自己的权限：show grants;查看别的mysql用户权限：show grants for b@localhost; （前提自己的权限一定要比查的用户权限高）四，撤销已经赋予给mysql用户权限的权限revoke all on . from b@localhost;五， 授权grant all on . from to b@localhost with grant option;六 ，grant给用户赋予权限时，如果用户不存在，会自动重建grant select on myschool. to d@localhost identified by ‘1234’;七， 使用mysqladmin命令修改账户密码mysqladmin -u a -p password “6789”八 ， 登录mysql服务器后，室友set命令修改当前用户密码set password = password (‘1234’); set password for a@locakhost = password (‘1234’);ATM存取款系统 #客户信息表create table userInfo(customerID int primary key auto_increment,customerName char(10) not null,PID char(30) not null,telephone char(30) not null,address varchar(10)); #银行卡信息表create table cardInfo(cardID char(30) primary key,curID varchar(10) not null default’RMB’,savingID int not null,openDate datetime default NOW(),openMoney decimal not null,balance decimal not null,password varchar(10) not null default’888888’,isReportLoss bit not null default 0,customerID int not null,foreign key(savingID) references deposit(savingID),foreign key(customerID) references userInfo(customerID)); #交易信息表create table tradeInfo(transDate timestamp not null default NOW(),cardID char(30) not null,transType char(10) not null,transMoney decimal not null,remark text,foreign key(cardID) references cardInfo(cardID)); #存款类型表create table deposit(savingID int primary key auto_increment,savingName varchar(10) not null,descrip varchar(10) );#给客户信息表添加信息insert into userInfo(customerName,PID,telephone,address)values(‘丁六’,’567891321242345618’,’0752-43345543’,’北京西城区’),(‘王五’,’56789123453212456x’,’010-4444455555’,’河北石家庄市’),(‘张三’,’1234567890123456789’,’010-67898978’,’北京海淀区’),(‘丁一’,’334456889012678’,’2222-63598978’,’河南新乡’),(‘李四’,’321245678912345678’,’0478-44443333’,’山东济南市’); #银行卡信息表添加信息insert into cardInfo(cardID,curID,savingID,openDate,openMoney,balance,password,isReportLoss,customerID)values(‘1010357612121004’,default,1,default,’1’,’1001’,default,1,1),(‘1010357612121130’,default,1,default,’1’,’1’,default,1,2),(‘1010357612345678’,default,2,default,’1000’,’6100’,default,1,3),(‘1010357619148284’,default,2,default,’1000’,’1000’,default,1,4),(‘1010357612121134’,default,1,default,’1’,’1501’,default,default,5);alter table cardInfo modify column cardID char(30);alter table tradeInfo modify column cardID char(30);alter table drop foreign key cardID;DROP TABLE cardInfo; #交易信息表添加数据insert into tradeInfo(transDate,cardID,transType,transMoney,remark)values(default,1010357612121004,’存入’,1000,null),(default,1010357612345678,’支取’,900,null),(default,1010357612121130,’存入’,300,null),(default,1010357612345678,’存入’,2000,null),(default,1010357612345678,’存入’,2000,null),(default,1010357612345678,’存入’,2000,null), (default,1010357612121004,’存入’,1000,null);#修改李四的卡号为（1010357612121134）密码123123update cardinfoset cardID=’1010357612121134’,password=’123123’where customerID=(select customerID from userinfo where customerName=’李四’); #申请李四挂失update cardinfoset isReportLoss=1where customerID=(select customerID from userinfo where customerName=’李四’); #统计总存入金额，和支取金额select transType as ‘资金流向’,sum(transMoney) as’总金额’from tradeinfogroup by transType; #查询本周开户信息select * from cardinfo where week(opendate)=week(now()); #查询本月交易金额最高的账号select cardID as ‘卡号’,sum(transMoney) as’总金额’from tradeinfogroup by cardIDorder by sum(transMoney) desclimit 1; #查询挂失客户select customerName AS ‘客户姓名’,telephone as’联系电话’from userinfo where customerid=(select customerid from cardinfo where isReportLoss=1); #查询余额少于200的客户select customerName as’客户姓名’,telephone as ‘联系电话’,balance as’余额’from cardinfoinner join userinfo on cardinfo.customerID=userinfo.customeridwhere balance&lt;200; #创建银行客户记录视图create view view_userInfoasselect customerID as ‘客户编号’,customerName as ‘开户名’,PID as ‘身份证号’,telephone as ‘电话号码’, address as ‘居住地址’from userinfo;查看该视图select * from view_userInfo; #创建银行卡记录视图create view view_vardInfoasselect cardID as’卡号’,customerName as ‘客户’,curID as ‘货币类型’, deposit.savingName as ‘存款类型’, openDate as ‘开户日期’, balance as ‘余额’, password as ‘密码’,cardinfo.isReportLoss as ‘是否挂失’from cardinfoinner join userinfo on cardinfo.customerID=userinfo.customeridinner join deposit on cardinfo.savingID=deposit.savingID #创建银行卡的交易记录视图create view view_transInfoasselect transDate as ‘交易日期’,transType as ‘交易类型’, cardID as ‘卡号’,transMoney as ‘交易金额’, remark as ‘备注’from tradeInfo; #使用事务完成转账，李四转给张三300START TRANSACTION;update cardinfoset balance=balance-300where cardID=’1010357612345678’;update cardinfoset balance=balance+300where cardID=’1010357612121134’; COMMIT;JDBC1、JDBC是Java数据库连接技术的简称，提供连接各种常用数据库的能力2、提供成需要调用的接口与类java.sql和javax.sqlDriverManager类：装载驱动程序，Connection接口：负责连接和传递数据Statement接口：由connection产生，负责执行SQL语句ResultSet接口：负责保存和处理Statement执行后的查询结果使用纯Java方式连接数据库由JDBC驱动直接访问数据库优点：100%Java，快又可跨平台缺点：访问不同的数据库余姚下载专用的JDBC驱动案例： 分层的特点1、每一层都有自己的职责2、上一层不用关心下一层的实现细节，上一层通过下一层提供的对外接口来使用其功能3、上一层调用下一层的功能，下一层不能调用上一层功能分层开发的优势代码复用分离开发人员的关注无损替换降低了系统间的依赖第一层：数据访问层（DAO）dao:接口 dao.impl：接口的实现第二层：业务逻辑层(BI,BIZ)service:接口 service.impl:接口的实现第三层：表示层(UI)第四层：text:测试类第五层：entity:实体包,存放实体专用第六层：utils:工具包，负责存通用工具包案例： BaseDao包中的方法两个主要方法其中还有加载驱动，创建连接，关闭连接 1、实体类可以加 Serializable接口不起任何作用，但可以规范代码 二、jdbc优化操作步骤1、在src下新建File文件起名“database.properties” 2、在BaseDao中添加init()方法，将init（）方法加入到加载驱动中","categories":[],"tags":[]},{"title":"JAVA","slug":"java","date":"2015-09-17T03:12:19.000Z","updated":"2018-12-01T03:24:05.753Z","comments":true,"path":"2015/09/17/java/","link":"","permalink":"http://yoursite.com/2015/09/17/java/","excerpt":"","text":"什么是JDK：JDK全称(java Development kit)java 工具开发包就是是能够实行编译和运行的功能 jdk中的重要文件： Jvm：java virtual machine(java虚拟机)java程序就在JVM中运行的java核心类库：已经编写好的java类 如何配置环境变量： 计算机—属性—高级系统设置—环境变量。在新的打开界面中的系统变量需要设置三个属性 1.“JAVA_HOME” 2.“path” 3.“classpath”,其中在没安装jdk的环境下。path属性是本来就 存在的。而JAVA_HOME和classpath是不存在的。步骤：一、点击“新建”，然后在变量名写上JAVA_HOME，故名起义该变量的含义就是java的安装路径，点开jdk以后的路径例如（”C：\\jdk1.6.0”）二、其次在环境变量里面找到path，然后点击编辑新建一个变量值为javajdk中bin的路三、最后在新建一个classpath，该类变量的含义是java加载类，（class or lib）路径，只有类在classpath中， java命令才能识别。其值为”.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;”.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar;方法2：在eclipse中配置环境变量步骤： Window—-Preferences—-Java—-Installed JREs—-Add—Next&gt;—-Directory—-选择java文件下的JDK1.7—确认—-Finish—-选择添加的路径—-OK如何显示文件的后缀名：打开计算机–打开工具–右击打开最后一个 文件夹选项–点击查看–寻找”隐藏已知文件类型的扩展名” 进制转换： 数 据 的 量：1.常量：在程序的云心期数据不会发生变化的量就是常量整数的常量： 24小时（24进制），365天（365进制）小数的常量：圆周率3.14字符：’男’ ‘女’布尔类型： true,false空常量：null2.变量：基本数据类型有8中： 整数类型： 小数类型： 小数类型所表示的数据范围要比整数的最大范围大8bit=1byte1024byte=1kb1024kb=1mb1024mb=1gb1024gb=1tb1024t=1pb字符类型：char 2字节布尔类型：boolean true falseboolean值的初始值是 ：false; 操作字符串的方法：length（） //获取长度quals（） //不忽略大小写比较值toLowerCase() //转换小写toUppterCase() //转换大写equalsIgnoreCase()//忽略大小写比较concat() //连接字符串indexOf() //提出字符串 split() //拆分字符串数据类型转化1、自动转换（整数类型的转换）（小空间的数据据类型向大空间的类型去转换）1、8种数据类型除了boolean类型以外都可以转换2、变量在做计算的时候可能出现溢出的情况3、小空间的数据类型和大空间的数据类型计算会向大空间的数据类型转换4、byte、short、char在做运算的时候会自动提升数据类型成int5、int和其他数值计算也会溢出，但不会提升会损失精度6、任何的整数类型和long类型做运算都会转换成long类型7、常量在做运算的时候只要不超出定义的数据类型的范围就不8、char类型可以转换成其他类型（除了boolean）会报错，也不会自动提升byte a=12;byte b=a+1;//会报错int b=a+1;//正确//byte在做运算的时候会自动的提升成intshort a=30;short b=a+1;//会报错int b=a+1;//正确//short在做运算的时候会自动的提升成intchar a=’a’;int b=a+3;//输出结果为100,a 在ascii码种代表到数字97short a=3+4;//不会报错因为系统知道不会报错（范围内） 自动转换（小数类型的转换 ）1、float类型和所有整数类型计算都会转换成float2、double类型和任何整数类型计算都会转换成doublefloat f=12.5f;//float类型和常量计算不会有类型提升类型float f1=f+1;//结果为13.5；//float类型和float类型计算不会有类型提升类型float f2=f1+f; //结果为26.0；//float类型和所有整数类型计算不会提升类型int b=100;float f3=f+b //结果为112.5；//double和常量计算会自动转换成doubledouble d=120.6+1;2、强制转换（大空间的数据据类型向小空间的类型去转换）1、把整形强制转换成byte,强制转换有可能损失精度，因为要转换的变量可能超过目标类的最大值2、整数转小数，会自动转换，小数转整数会舍弃小数；格式：int i=100;byte a=(byte)i; 运算符 1、算术运算符(+ 、 - 、 * 、/ 、%、++、–、)++、–在前先进行运算再使用，++、–在后先使用再运算三目：a&gt;b?true:false 说明：当a大于b的时候，为true（也就是冒号之前的值），否则为false；这整个运算符包括一个关系运算符（可以是“&gt;””&lt;””!=”等等），一个“？”，一个“：”，冒号前后需要有两个表达式或者是值或者是对象。2、比较运算符(== 、 ！= 、 &gt; 、&gt;= 、&lt;、&lt;=)( 等于:==，不等于:!= ，大于:&gt;， 小于:&lt;，大于等于:&gt;= ，小于等于:&lt;= )3、逻辑运算符(&amp; 、| 、 ^ 、&amp;&amp; 、||、!)4、位运算符(&lt;&lt; &gt;&gt; &gt;&gt;&gt; &amp; | ^) int a=2;//把a变量的二进制的值左移2位System.out.println(a &lt;&lt; 2);itn b=3;//把b变量向右移动2位System.out.println(b &gt;&gt; 2); 5、三元运算符：三元运算符适合判断两个值到底使用哪一个情况char sex 6 == 6 ? ‘男’ : ‘女‘//表达式为真返回“ : ”前面的值,假返回后面的值 switch中的条件只能是（byte,short,int,char,String）正则表达式 形参和实参：执行方法前放进的参数叫做实参，被执行的方法的参数叫做形参案例： 方法中 a,b的值是实参： 方法a,b的值是形参： 引用传递和值传递：值传递：public class Test3 { public static void change(int a){ a=50; } public static void main(String[] args) { int a=10; System.out.println(a); change(a); System.out.println(a); }}很显然输出的 是10，10。传递的是值得一份拷贝，这份拷贝与原来的值没什么关系。对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。 方法的重载：重载（overload）:在一个类中有两个或者两个以上同名的方法，但是参数不同（两个方法的参数个数不同，参数的类型不同）重载的目的：提高代码的可读性案例1： 案例2: 二维数组二维数组就是集合中套集合语法：数据类型 [] [] 数组名 = new 数据类型 [2] [3]案例： 使用二分法查找数组中对应数的索引：案例1： 注意：数组必须从小到大排序； 局部变量和成员变量的区别局部变量：1、在方法中或者在语句块中2、局部变量不许赋值才能使用3、都存储在栈中4、生命周期：定义的时候产生，当前方法执行完消失5、static不能修饰局部变量成员变量：1、在类里面定义2、可以不赋值，如果不赋值会有默认值3、存储在堆中4、生命周期：随着对象消失而消失，会被JVM的垃圾回收器回收 匿名对象：（匿名对象是无意义的，因为在栈中没有一个变量对它做引用，很快就会被垃圾回收器收掉，在实际开发中要避免匿名对性） 构造器：构造器语法：public 类名(数据类型 参数名，….){ }目的：创建对象构造器特点：1、方法名和类名一致2、方法没有返回值没有void3、参数可有可无注意：如果类中没有带有参数的构造器，就可以使用一个隐藏的默认构造器来创建对象，如果一旦有带有参数的构造器，默认的构造器就会被覆盖。我们可以显示的定义出来默认构造器就可以使用了。通过this(实参列表)可以调用本类中的构造器，必须注意，this必须是在方法中的第一行 Static关键字（静态）解释：static在java中表示的是静态，也就是项目在初始化运行的时候就会把静态的方法、变量加载到内存中，方便参数的获取和方法的调用。备注：静态变量必须在初始化之前进行赋值，否则会报错。静态方法通常都是被经常使用的方法，不需要每次都重新实例化，提高工作效率。 static表示不要实例化就可以使用，static修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问1、修饰在属性上定义类属性：static 数据类型 变量名(用static修饰的属性永远不会改变值)类属性访问：类名.属性名（推荐使用）对象名.类属名2、修饰在方法上定义类方法：（没有static的方法是对象方法）public static void 方法名（数据类型 参数名..）{方法体return 结果}类方法的调用 ：类名.类方法名（推荐使用）对象.类方法名（不建议使用）在类方法中不能使用对象的属性。只能用类属性 静态方法和非静态方法实例：public class Per{public static String getType(){return “人类”;}public String getName(){return “张三”;}}上面这个类中的getType方法，在没有new对象前这就可以这样用：String type=Per.getType();//type=”人类”;而getName方法则不能这样使用，编译都不会通过getName必须这样:Per p=new Per();String name=p.getName();//name=”张三”;当然，getType方法也可能通过对象调用:String type=p.getType();//type=”人类”;静态方法内部不能有非静态方法需要实例化，而非静态方法内是可以直接用静态方法的 单 例 模 式（Singleton）目的：确保一个类只有一个实例，自行实例化并向系统提供这个实例1、单例模式的创建步骤：（1）将默认啊的构造器私有化（2）在类中定义一个当前类的类型的静态属性，便且创建该当前类的对象（3）提供一个静态的类方法来返回当前类的静态属性的对象懒汉模式： 饿汉模式： 继承继承的特点：1、如果父类中包含了某些类中的共同的属性和性为，我们可以使用继承来设计程序。2、子类使用extends关键字继承父类的共同属性以外，子类还可以有自己特有的属性或者方法。3、父类更通用，子类更具体4、子类只能获得父类中的非private的属性，如果想要继承就得提供公共的set和get的方法，私有的方法是无法继承下来的5、java中只能做单继承6、提高代码的可读性 Super关键子1、子类实例化的过程中父类的构造器用先被调，然后再调用子类的构造器2、子类被调用的时候父类的默认构造器就会被调用(父类如果存在着有参数的构造器，一定要把默认构造器显示的定义出来)3、super()的调用必须要放在方法的第一行4、 子类在调用父类的有参数的构造器的时候使用，super(参数列表)这时父类的默认构造器就不会被调用了5、super可以表示父类的引用，我们可以使用super和this来区别父类和子类中同名的属性，在这种子类中访问属性的查找顺序首先在子类中查找指定的属性名字，如果在子类中没有该属性，那么就去父类中查找该属性，方法也是一样的当子类和父类有同样的方法时通过子类调用这个相同的为方法时调用的是子类的方法，但是我们可以通过super对父类的引用来调用父类的方法。 this关键子1、代表当前类的指定实例的引用2、可以区分同名的属性和局部变量3、通过this可以调用同类中的构造器（this（）,this(参数列表)）4、调用本类里面的属性，this.属性名，this.方法名（） 抽象类抽象语法:public abtract 返回值类型或【void】 方法名（参数列表）；没有方法体//如果在一个类中存在一个方法，那么这个类一定是抽象类，这个类上也要有abstract标识抽象类的语法：abstract class 类名{属性方法}注意：抽象类中可以没有抽象方法，但是有抽象方法的类一定是抽象类；抽象方法的概念：当多个具体的实体类存在着共同的行为，但是有不同的表现，我们在父类继承过程中父类的方法具体实现不能确定，但是可能确定的是他们都有这种行为。我们要把这种行为方法作为抽象方法抽象类的特点：1、抽象类不能被实例化2、抽象类必须被子类继承才能使用子类实例化3、继承了抽象类的非抽象类必须实现抽象类的所有抽象方法4、抽象类也可以继承抽象类，这样不需要实现父抽象类的方法5、抽象类的抽象方法不能和private，final, static共存。实例：抽象类： 继承抽象类：如果一个子类继承了抽象类的方法，那么就一定要实现抽象类中的抽象方法 main方法： 接口什么是接口：当一个抽象类，如果抽象类中的所有方法都是抽象的，那么我们就可以把它定义为一个接口，接口是对行为的抽象，类是对属性和行为的抽象语法：interface 接口名{方法的定义；……}接口的特点：1、在接口中每一个方法的定义都是抽象的，可以省略abstract2、接口是不可以实例化的，需要有类来实现接口实现接口的语法：class 类名 implements 接口名，接口名…{//必须实现每一个接口中的每一个方法}3、接口中的方法不能和private，static和final共存4、在接口中可以定义属性，可以通过接口的实现类的实例来访问，还可以通过接口名来访问（推荐使用），接口中的属性不能修改，我们接口中的属性都是默认final static的，通过在接口中来定义属性把它作为常量，常量的名字规范是单词大写，而且多个单词之间用下划线来分割。比如：FLILE_PAT5、接口可以继承接口案例： 输出结果： 接口继承接口 练习题：（使用接口求圆的周长和面积）main方法： 接口和类： 数值类型转换有两种：double转int强制转换和int转double自动转换；=和==的区别：“=”是把右边的表达式赋给左边的变量名，“==”是将左右的存储地址进行比较成立为true不成立为false==和 equals的区别：“==”比较的是路径新建的String i=new String(“ff”)和String z=new String(“ff”)计较每个路径都是新建立的所以结果为false。String i=”ff”和String z=”ff”比较可以用”==”因为他们的值放在池里经过的路径一样没有新建一个路径所以路径用的是一样的结果为true。“.equals”比较的是值，只要值相等结果就为truebread和continue的异同点：break和continue都是控制循环结构的，主要是停止循环。break：有时候我们想在某种条件出现的时候终止循环而不是等到循环条件为false才终止。这时我们可以使用break来完成。break用于完全结束一个循环，跳出循环体执行循环后面的语句。continue：continue和break有点类似，区别在于continue只是终止本次循环，接着执行后面的循环，break则完全终止循环。可以理解为continue是跳过当前循环中剩下的语句，执行下一次循环。for循环执行顺序：1.执行初始化2.执行条件判断3.根据循环结构判断条件为true继续执行，为假false退出循环不再执行4.执行迭失部分（i++）依次执行3、4步骤直到条件不成立退出字符串方法使用String对象存储字符串：String s=”Hello World”; //存储在栈中String s=new String(); //存储在堆中String s=new String(“Hello World”); //存储在堆中String类位于java.lang包中，具有丰富的方法： 计算字符串的长度、比较字符串、连接字符串、提取字符串String类提供的equals()方法，比较存储在两个字符串对象的内容是否一致“==”和equals()有什么区别？1、==是判断两个变量或实例是不是指向同一个内存空间equals是判断两个变量或实例所指向的内存空间的值是不是相同2、==是对内存地址进行比较equals（）是对字符串的内容进行比较3、==指引用是否相同equals()指的是值是否相同 百文百鸡：小鸡一文三只，公鸡5文一只，母鸡3文一只，100文怎么买100只鸡：利用二重循环实现用整形变量g和m分别表示要买的公鸡和母鸡数，则g不会超过20，m不会超过33。用整形变量k（3的倍数）表示小鸡数，一共100文钱，则可以得到：5g+3m+x/3=100一共买了100只鸡，则有：g+m+x=100 显示结果： 鸡兔同笼：上有35头下有94足求个数假设 j为鸡 t为兔j+t=35;j2+t4=94;显示结果： 等腰三角形： 输出结果： 数组：数组就是一个变量用于将相同的数据类型的数据存储在内存中，数组中的每一个数据元素都属于同一数据类型。数组的基本要素：标识符：首先，和变量一样，在计算机中，数组也要有一个名称，称为标识符，用于区分不同数组。数组元素：当给出了数组名称，即数组标识符后，要向数组中存放数据。这些数据就称为数组元素。数组下标：在数组中，为了正确地得到数组元素的元素，需要对它们进行编号，这样计算机才能根据编号去存取，这个编号就称为数组下标。声明数组2种方式：int[] scores1;//推荐int scores2[];数组开空间方式:scores2=new int[5];//长度必须写赋值3种方法:方法1：索引号逐一赋值scores1[0]=90;scores1[1]=100;scores1[2]=99;……scores1[scores1.length-1]=77;方法2：边开空间便赋值int[] score3=new int[]{1,5,6,8,11,23};方式3：边声明边赋值int[] scores4={45,34,23};数组排序：使用 Arrays.sort() 方法将数组名放到括号里九九乘法表： 菱形： 练习题：1、定义四个变量，a=’A’;b=’B’,c=’C’,d=’D’;现在编程实现a与d变量中的值交换，b与c中的值交换。最后输出a、b、c、d中的值 2、老师说小明考试达到90分以上则奖励一个优盘,80分以上奖励一个java疯狂讲义,70分以上奖励一个本子否则什么都不奖励,还要罚写抄书50遍。 3、从键盘上输入一个5位数,把每位上的数相加,求和。方法1： 方法2： 4.已知数组中有值{1,3,5,9},实现从键盘随意输入一个数插入到数组中,顺序有低到高排列 5、输出1-100偶数的个数和奇数的个数各有多少 6、输入一串字符查找某一个字出现的次数 如何创建字符串：String s=”Hello world”;//创建一个”Hello world”字符串String s=new String();//创建一个空的字符串String s=new String(“Hello world”);//创建一个”Hello world”字符串忽略大小写比较：String s=”tom”;s.equalslgnoreCase(“TOM”);//运算结果为true;操作字符串的方法：replace() //前后两个参数用于替换length（） //获取长度quals（） //不忽略大小写比较值toLowerCase() //转换小写toUppterCase() //转换大写equalsIgnoreCase()//忽略大小写比较concat() //连接字符串indexOf() //提出字符串split() //拆分字符串字符串方法：String s=”青春无悔”;int index=s.indexOf(“春”);输出结果为“1”下标从0开始，查找字符串串下标的位置，“春”为下标1String s=”青春无悔无悔青春”;int index=s.lastIndexOf(“青春”);输出结果为“6”下标从0开始，查找最后一次出现的字符返回“青春”的首字符位置String s=”青春无悔无悔青春”;String s=”青春无悔无悔青春”;String result=s.substring(1,4);输出结果为“春无悔”括号里前面写下标从0开始找开始位置，后面写结束的下标位置从1开始，String s=”青春无悔无悔青春”;String[] ss=s.split(“”);括号里面必须写””号，””填要拆分的字符，不填写就拆分成子字符String s=”hello,world”;String str=s.replace(“,”,” “);//替换把s中的“，”替换为空格常用的StringBuffer类提供的方法：转换成String类型 ：ToString();连接字符串： append();插入字符串： insert(索引，”字符“);随机数1–10公式:(int)(1+math.random()(10-1+1))Java随机数指定位置公式：(数据类型)(最小值+Math.random()(最大值-最小值+1))int b=(int)(100+Math.random()*(999-100+1));C#随机数：Random random = new Random();int num = random.Next(最小值, 最大值); 对象和封装查看类图： 类名首字母大写属性名和方法名首字母小写 常量名全部大写单词中间用“_”分割构造方法：方法名与类名相同方法没有返回值主要完成对象的初始化工作 this()表示当前类的无惨构造方法，自能在构造方法中使用，而且必须时第一行方法的重载：在一个类中有两个或者两个以上同名的方法，但是参数不同（两个方法的参数个数不同，参数的类型不同） 重载的目的：提高代码的可读性，复用性值类型和引用类型1、值类型（struct、float、bool、enum、int 、double……）改变一个变量的值不会影响另一个变量的值2、引用类型(delegate、class、interface、object、string.数组…..)string 是一个特殊的引用类型，传递参数不会保留值 改变其中一个数组的值另一个数组改变（指向同一个存储空间所以共用的是一个数组）2、再C#中静态属性不能通过对象名 . 调用，只能通过类名 . 掉用。再Java中两个都可以静态代码块只能给static的属性赋值,比构造方法先执行一步案例：static{name=”朱熔政”;System.out.println(“我是代码块”); } 封装封装快捷键：右击空白区域选择Source→Generate Getter and Setter→Select All→OK1、将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问封装的好处：1、隐藏类的实现细节2、只能通过规定方法访问数据3、方便加入控制语句4、方便修改实现实现方法： 1、修改属性为Private→2、创建公有的getter/setter方法→3、对属性值的合法性进行判断Static关键字（静态）1、static不能修饰局部变量2、static关键字所修饰的是类的成员，而非实例成员3、static修饰的属性会长期占用内存3、静态类中不能出现 this和super关键字6、加载类的过程中，完成静态变量的内存分配，在执行静态块，两者实在创建对象之前完成的 7、普通类是不允许声明为静态的，只有内部类才可以。Java对象的初始化顺序 重点：静态方法先被加载，普通方法调用的时候才加载继承的概念继承extends 继承关键字（翻译：扩展）1、如果父类中包含了某些类中的共同的属性和性为，我们可以使用继承来设计程序。2、子类使用extends关键字继承父类的共同属性以外，子类还可以有自己特有的属性或者方法。3、父类更通用，子类更具体4、子类只能获得父类中的非private的属性，如果想要继承就得提供公共的set和get的方法，私有的方法是无法继承下来的5、java中只能做单继承6、子类不能继承父类的构造方法可以引用7、Object类是所有类的祖先，再定义一个类时这个类就继承了Object Object类的六个方法：1、equals（），2、getClass()，3、hashCode()，4、notify(),5、notifyAll()，6、toString()super关键字1、super()的调用构造方法必须要放在方法的第一行2、super可以表示父类的引用，我们可以使用super和this来区别父类和子类中同名的属性 3、super出现在子类的方法和构造方法中，而不是其他地方抽象类(abstract)抽象语法:抽象方法的语法：public abtract 返回值类型 方法名（参数列表）；//没有方法体如果在一个类中存在一个抽象方法，那么这个类一定是抽象类抽象类的语法：abstract class 类名{属性方法}注意：抽象类中可以没有抽象方法，但是有抽象方法的类一定是抽象类；抽象方法的概念：当多个具体的实体类存在着共同的行为，但是有不同的表现，我们在父类继承过程中父类的方法具体实现不能确定，但是可能确定的是他们都有这种行为。我们要把这种行为方法作为抽象方法抽象类的特点：1、抽象类不能被实例化2、抽象类必须被子类继承才能使用子类实例化3、继承了抽象类的非抽象类必须实现抽象类的所有抽象方法4、抽象类也可以继承抽象类，这样不需要实现父抽象类的方法5、抽象类的抽象方法不能和private，final, static共存。7、abstract可以用来修饰方法和类，但不能修饰属性和构造函数 8、抽象类中的构造方法可以正常使用重写（override）1、子类重写父类方法，方法的返回值，方法名，方法参数要和被重写的方法完全相同 2、方法重写不能缩小被重写方法的访问权限final关键字（最终的）1、final关键字修饰的变量叫常量（不会改变的值）常量的变量名全部大写2、final修饰的类不能继承3、final修饰的属性不能被修改4、final修饰的方法不能被子类重写5、final修饰引用型不能再引用6、final和abstract是功能相反的两个关键字 7、final可以用来修饰类，属性，方法，不能修饰构造函数多态没有继承就没有多态1、将一个父类的引用指向一个子类对象，称为向上转型，自动进行类型转换2、此时通过父类引用变量调用的方法是子类覆盖父类或继承父类的方法，不是父类的方法3、此时通过父类引用变量无法调用子类特有的方法4、但是可以将父类的这个引用变量通过强制类型转换为子类对象案例：Pet pet=new Dog(“欧拉”,”哈士奇”)；//类型的自动转换pet.eat()； //父类有的方法才可以调用出来pet.catching() //子类的方法父类的引用对象调用不出啦会报错Dog dog=(Dog)pet; //强制类型转换为狗狗类dog.catching()； //这样就不会报错了Penguin pen=(pen)pet;//会保存因为这个引用变量指向的是狗狗类，不能转化为其他类instanceof 运算符用来进行类型判断；1、使用instanceof判断类型时，两个判断的变量要有子父类关系2、instanceof通常和强制类型转换一起使用向上转型——子类转换为父类（自动转换） 向下转型——父类转换为子类（结合instanceof强制转换）接口interface语法：定义接口：interface 接口名{方法的定义；……}接口继承接口： public interface 接口名 extends 父接口1，父接口2，….{//常量定义//抽象方法定义}implements继承实现接口：class 类名 extends 父类名 implements 接口1，接口2，….{//类成员//必须实现每一个接口中的每一个方法}1、接口中的属性都是静态全局常量，都会用public static final修饰，接口中的常量必须在定义时指定初始值2、接口中所有方法都是抽象方法，接口中的方法都会自动用public abstract修饰，既接口中自有全局抽象方法3、接口不能实例化，接口中不能有构造方法4、接口中可以通过extends实现继承关系，一个接口中可以继承多个接口，但接口不能继承类5、接口的实现类，必须实现接口的全部方法，否则必须定义为抽象类6、通过implements实现多个接口，extends必须在前7、接口的属性和方法不能私有化接口和抽象类的共有特点：1、都不能实例化 2、不能和private，static和final共存异常异常是指在程序的运行过程中所发生的不正常的事件，它会中断正常的程序快捷键：Shift+Alt+Z1、如果try语句块在执行过程中遇到异常，并且这个异常与catch中声明的异常类型匹配，那么在try块中剩余的代码将被忽略，但如果catch中没有声明的异常，那么将立刻退出程序2、无论异常有没有被catch块捕获，都会执行finally，有return的话也会先执行finally3、System.exit(1) 表示退出程序异常处理关键字：捕获异常：try:执行可能产生异常的代码（此处不会产生异常）catch:捕获异常finally:无论是否发生异常代码都执行,只有一种情况不走finally System.exit(1) //退出java虚拟机抛出异常：throw：手动抛出异常声明异常： throws：声明方法可能抛出的各种异常异常中的方法：1、获得异常信息：e.getMessage()2、获得异常的内存堆栈信息及错误的位置 e.printStackTrace()多重catch块执行其中的一条catch语句后，其后的catch语句都将被忽略，排列的顺序必须从子类到父类，最后一个一般都是Exception类案例： throws声明异常声明某个方法可能抛出的各种异常，throws可以同时声明多个异常，之间用逗号隔开，通过try-catch捕获并处理异常案例： throw手动抛出异常案例： 测试类： 异常分类：Throwable类：所有异常类的父类，派生两个子类Error和ExceptionError类：表示仅靠程序本身无法恢复的严重错误，例如虚拟机的错误，内存溢出等Exception类：由java应用程序抛出和处理的严重错误，如所需文件找不到，网络中断，除数不能为0，数组下标越界等RintimeException类：运行时异常 常见的异常类型： | InputMismatchException | 赋值错误内容不匹配 | Scanner中的 .hasNextInt()方法返回一个布尔值，判断两次输入的数是否都为整数是的话返回 true，非整数返回fase; System.err.println(“”),也是输出语句.只不过输出的字体是红色的throw和throws的区别表现在以下三个方面1、作用不同：throw用于在程序中抛出异常；throws用于声明在该方法内抛出了异常2、使用的位置不同：throw位于方法体内部，可以作为单独语句使用；throws必须跟在方法参数列表的后面，不能单独使用 3、内容不同：throw抛出一个异常对象，而且只能是一个；throws后面跟异常类，而且可以跟多个异常类Log4j主要用来记录系统中一些重要操作，便于监视系统运行情况，帮助用户提前发现和避开肯出现的问题，或者出现问题后根据日志找到原因日志级别:fatal &gt; error &gt; warn &gt; info &gt; debug 实现步骤：1、在项目中加入log4j所用的JAR文件2、创建log4j.properties文件3、编写log4j.properties文件，配置日志信息4、在程序中使用log4j记录日志信息 集合框架 位于java.util包中 Collection接口：LIst接口继承Collection存储不唯一，有序（插入顺序）的对象1、ArrayList：存储方式和数组相同,优点：遍历元素和随机访问元素效率高；2、LinkedList：优点：插入、删除元素效率高；提供了额外的addFirst（）、addLast()、removeFirst()、removeLast()、getLast()、getFirst()等方法Set接口继承Collection存储一组唯一，无序的对象Map接口：(存储成对的键、值对象)1、HashMap:即一个键对象和一个值对象，可以根据键实现对应值的映射ArrayListArrayList.set(1,”df”);//修改一的位置的值为df;Collections.sort(ArrayList);//对集合进行排序 import java.util.List;//LIst接口包import java.util.ArrayLIst；//ArrayLIst包 LInkedList(链表集合)lst.peek();//删除第一个元素 import java.util.LInkedList；//包 HashMap(键值集合)import java.util.Map;//Map包import java.util.HashMap; 泛型集合（List&lt;类型&gt;） 键值集合（HashMap&lt;类型&gt;） 多线程进程和线程什么是多线程？1、如果在一个线程中同时运行了多个线程，用来完成不同的工作，则称为“多线程”；2、多个线程交替占用CPU资源，而非真正的并行执行进程:一个应用程序就是一个进程，进程只是一个概念线程:线程是进程的一部分，至少有一个线程这个线程被称为主线程多线程好处：1、充分利用CPU的资源2、简化编程模型3、带来良好的用户体验Thread类java.lang.Thread类中持多线程编程主线程main（）方法即为主线程入口，1、产生其他子线程的线程2、必须最后完成执行，因为它执行各种关闭动作主线程的引用通过currentThread()方法获得（单利模式）setName()改变线程名称，getName()获取线程名称线程的状态：创建状态、就绪状态、运行状态、杜塞状态、死亡状态线程调度方法： 创建线程类有两种方式：方式一(继承Thread类) 测试类： 方式二（实现Runnable接口） 测试类： setName() 获取和设置线程名： setPriority() 设置线程优先级：（0~9数字越大优先的几率越高，不能保证一定优先） sleep() 设置线程休眠：（以毫秒为单位） join() 强制执行(哪个对象 . join()哪个强制执行) yield() 设置线程礼让：(提供一种可能性，不能保证一定礼让，礼让的线程处于就绪状态） 线程不安全问题：多个线程操作同一共享资源时，将引发数据不安全问题案例： 运行结果： synchronized 解决线程不安全问题：方法一（同步方法）方法二（关键字修饰代码块）1、同一时刻只能有一个线程进入synchronized(this)同步代码块2、当一个线程访问一个synchronized(this)同步代码块时，其他synchronized(this)同步代码块同样被锁定 3、当一个线程访问一个synchronized(this)同步代码块时，其他线程可以访问该资源的非synchronized(this)同步代码多线程中使用vector集合，单线程中使用ArrayList不带锁的方法称为非同步方法，例如ArrayList类的add()vector集合是安全的Hashtable和HashMap的区别Hashtable线程安全，HashMap线程不安全，效率低Hashtable的键和值都不能为空，HashMap键和值都可以为空，效率高 文件操作import java.io.FileFile类的常用方法 1、文件可认为是相关记录或放在一起的数据集合2、文件存储在，磁盘，光驱….中使用文件流的步骤：1、引入相关的类2、创建输入流/I输出流对象3、读取/写入文本文件的数据4、关闭相关的流对象案例： 流流是指一连串流动的字符，是以先进先出的方式发送信息的通道按流向区分流：输入流（读）：InputStream和Reader基类输出流（写）：OutputStream和Writer基类按处理数据单元划分：字节流：输入流InputStream基类，输出流Outputstream基类 字符流：输入流Reader基类，输出流Writer基类OutputStream是所有字节流的基类1、字节输入流：基类：InputStream子类：FileInputStream构造：FileInputStream(File file)FileInputStream(String name)方法：int read()按字节读，返回读到的字节read(byte[ ] b)读到字节数组，返回读入字节数组的长度read(byte[ ] b,int off,int len)读到字节数组，素组的开始位置，和结束位置案例： 2、字节输出流基类：outputStream子类：FileOutputStream构造：FileOutputStream(File file)FileOutputStream(String name)FileOutputStream(String name,true/fase) true代表追加方法：close()flush()刷新缓冲区write(byte[ ] b)write(byte[ ] b,int off,int len)write(int b)案例： 3、同时执行读写字节：（复制） 4、字符输入流：（读）1、FileReader类基类：Reader构造：FileReader(File file)FileReader(String name)常用方法：int read()读取一个字符，返回字符编码int read(char[ ] b)读取一个字符数组int read(char[ ] b,int off,int len)读取一个字符数组，开始位置，和结束位置 2、BufferedReader类(缓冲流) 5、字符输出流：（写）1、FileWriter类基类：Reader构造：FileWriter(File file)FileWriter(String name)常用方法：int write(String str)读取一个字符，返回字符编码int write(char[ ] b,int off,int len)读取一个字符数组，开始位置，和结束位置void flush 刷新输出流案例：（读写操作） 2、BufferedWriter类（缓冲流） 分层开发分包，每个包有指定功能1、entity:实体层，存放实体类实体类:通常只用于存储某种事物的属性和自身普通方法的类，代表某一类的具体的东西，是我们程序运行的载体2、service:接口层，存放所有的接口3、biz:业务层，调实现的功能，负责连接用户的4、util:公共层，存储所有类共享的资源5、common：工具层，存储共享的工具6、dao:负责定义功能7、test:测试层","categories":[],"tags":[]}]}